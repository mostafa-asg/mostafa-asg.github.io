<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Performance on Software Engineering Blog</title>
    <link>https://mostafa-asg.github.io/tags/performance/</link>
    <description>Recent content in Performance on Software Engineering Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 24 Jan 2019 10:41:16 +0330</lastBuildDate>
    
	<atom:link href="https://mostafa-asg.github.io/tags/performance/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Load testing using K6</title>
      <link>https://mostafa-asg.github.io/post/k6-http-load-test/</link>
      <pubDate>Thu, 24 Jan 2019 10:41:16 +0330</pubDate>
      
      <guid>https://mostafa-asg.github.io/post/k6-http-load-test/</guid>
      <description>Introduction Understanding the performance of mission critical API is crucial. Before you deploy your API, probably you want to know, how your API behaves under heavy loads. Most API nowadays are HTTP-based, and that&amp;rsquo;s why there are numerous HTTP load testing tools available. Here is just a few:
 wrk wrk2 vegeta locust hey Apache Benchmark  Problem Most of them designed to generate load on the static url, like:</description>
    </item>
    
    <item>
      <title>Function Memorization in Go</title>
      <link>https://mostafa-asg.github.io/post/function-memorization-in-go/</link>
      <pubDate>Fri, 23 Mar 2018 22:20:14 +0430</pubDate>
      
      <guid>https://mostafa-asg.github.io/post/function-memorization-in-go/</guid>
      <description>Memoization is an optimization technique used to increase performance by storing the results of expensive function calls and returning the cached result when the same input occurs again. In this post I show how function memoization can be implemented in Go, in a pure functional manner.
Based on wikipedia definition, a function may be considered a pure function if both of the following statements about the function hold:
1. The function always evaluates the same result value given the same argument value(s).</description>
    </item>
    
    <item>
      <title>Enhance Hadoop MapReduce Speed for small jobs</title>
      <link>https://mostafa-asg.github.io/post/enhance-hadoop-mapreduce-speed-small-jobs/</link>
      <pubDate>Tue, 06 Feb 2018 07:15:50 +0330</pubDate>
      
      <guid>https://mostafa-asg.github.io/post/enhance-hadoop-mapreduce-speed-small-jobs/</guid>
      <description>Introduction There are some circumstances when input of Hadoop&amp;rsquo;s MapReduce is relatively small. Consequently the overhead of allocating and running tasks in new containers outweighs the gain to be had in running them in parallel, compared to running them sequentially on one node. Such a job is said to be uberized, or run as an uber task.
Enable uber optimization To enable uberized job, simply set mapreduce.job.ubertask.enable to true. But that is not sufficient.</description>
    </item>
    
  </channel>
</rss>