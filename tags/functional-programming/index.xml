<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Functional Programming on Software Engineering Blog</title>
    <link>https://mostafa-asg.github.io/tags/functional-programming/</link>
    <description>Recent content in Functional Programming on Software Engineering Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 23 Mar 2018 22:20:14 +0430</lastBuildDate>
    
	<atom:link href="https://mostafa-asg.github.io/tags/functional-programming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Function Memorization in Go</title>
      <link>https://mostafa-asg.github.io/post/function-memorization-in-go/</link>
      <pubDate>Fri, 23 Mar 2018 22:20:14 +0430</pubDate>
      
      <guid>https://mostafa-asg.github.io/post/function-memorization-in-go/</guid>
      <description>Memoization is an optimization technique used to increase performance by storing the results of expensive function calls and returning the cached result when the same input occurs again. In this post I show how function memoization can be implemented in Go, in a pure functional manner.
Based on wikipedia definition, a function may be considered a pure function if both of the following statements about the function hold:
1. The function always evaluates the same result value given the same argument value(s).</description>
    </item>
    
  </channel>
</rss>